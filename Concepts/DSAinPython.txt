Python has inbuilt Data structures which are used to store and manipulate data. These data structures are:

1. List
2. Tuple
3. Set
4. Dictionary

These data structures are used to store data in a specific way and can be used to perform various operations on the data.
List:
A list is a collection of items which are ordered and changeable. It is written with square brackets [].
Example:
python
```python
my_list = [1, 2, 3, 4, 5]
```
Tuple:
A tuple is a collection of items which are ordered and unchangeable. It is written with round brackets().
Example:
python
```python
my_tuple = (1, 2, 3, 4, 5)
```
Set:
A set is a collection of items which are unordered and unchangeable. It is written with curly brackets {}.
Example:
python
```python
my_set = {1, 2, 3, 4, 5}
```
Dictionary:
A dictionary is a collection of key-value pairs. It is written with curly brackets {} and each key-value pair is separated by a colon :.
Example:
python
```python
my_dict = {'name': 'John', 'age': 30, 'city': 'New York'}
``` 
These are the basic data structures in Python which are used to store and manipulate data.
These are called as ADT (Abstract Data Type)

ADT:
ADT is a theoretical concept in computer science which describes the behavior of a data structure without specifying its implementation. It is a way to define the properties and operations of a data structure without worrying about the underlying implementation.

ADT is a way to define the behavior of a data structure without worrying about the underlying implementation. It is a way to define the properties and operations of a data structure without worrying about the underlying implementation.

An abstraction is a mechanism for separating uses and implementation of an object.
Two common types of abstractions
procedural or functional abstraction
and data abstraction.

procedural abstracton:
The procedural abstraction is a way of hiding the implementation details of a procedure or function from the user.

Data abstraction:
The data abstraction is a way of hiding the implementation details of a data structure from the user.

ADT are used by set of operations called interface

Constructors Create and initialize new instances of ADT
Accessors: Return data contained in an instance without modifying it
Mutators: Modify the contents of an
ADT instance.
Iterators: Process individual data
components sequentially.

Computational complexity:

Computational complexity is a measure of the amount of computational resources (such as time and memory) required to execute an algorithm. It is used to compare the efficiency of different algorithms and to predict the performance of an algorithm on different inputs.

The computational complexity of an algorithm is usually expressed in terms of the size of the input to the algorithm. For example, the computational complexity of a sorting algorithm might be expressed as O(n log n), where n is the size of the input list.

There are two main types of computational complexity: time complexity and space complexity.
Time complexity is a measure of the amount of time an algorithm takes to execute, usually expressed in terms
of the size of the input. Space complexity is a measure of the amount of memory an algorithm uses, usually expressed in terms of the size of the input.

Analyze complexity:
Pratical/Experimental analysis: Measure the time and space complexity of an algorithm by running it on a variety of inputs and measuring the resources used.
Functional/Theoretical analysis: Analyze the time and space complexity of an algorithm using mathematical techniques such as asymptotic analysis.

order of n :
1:f(n) = 100n +1
2:f(n) = n^2 + 2n + 1
hence the order of n is n^2 for 2 solution algorithm and n for 1

O(1) - constant time complexity
O(log n) - logarithmic time complexity
O(n) - linear time complexity
O(n log n) - linearithmic time complexity
O(n^2) - quadratic time complexity
O(2^n) - exponential time complexity
O(n!) - factorial time complexity

Big O notation:
Big O notation is a mathematical notation that describes the limiting behavior of a function when the argument tends towards a particular value or infinity. It is used to describe the time complexity of an algorithm.
