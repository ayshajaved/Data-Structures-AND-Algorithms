Python has inbuilt Data structures which are used to store and manipulate data. These data structures are:

1. List
2. Tuple
3. Set
4. Dictionary

These data structures are used to store data in a specific way and can be used to perform various operations on the data.
List:
A list is a collection of items which are ordered and changeable. It is written with square brackets [].
Example:
python
```python
my_list = [1, 2, 3, 4, 5]
```
Tuple:
A tuple is a collection of items which are ordered and unchangeable. It is written with round brackets().
Example:
python
```python
my_tuple = (1, 2, 3, 4, 5)
```
Set:
A set is a collection of items which are unordered and unchangeable. It is written with curly brackets {}.
Example:
python
```python
my_set = {1, 2, 3, 4, 5}
```
Dictionary:
A dictionary is a collection of key-value pairs. It is written with curly brackets {} and each key-value pair is separated by a colon :.
Example:
python
```python
my_dict = {'name': 'John', 'age': 30, 'city': 'New York'}
``` 
These are the basic data structures in Python which are used to store and manipulate data.
These are called as ADT (Abstract Data Type)

ADT:
ADT is a theoretical concept in computer science which describes the behavior of a data structure without specifying its implementation. It is a way to define the properties and operations of a data structure without worrying about the underlying implementation.

ADT is a way to define the behavior of a data structure without worrying about the underlying implementation. It is a way to define the properties and operations of a data structure without worrying about the underlying implementation.

An abstraction is a mechanism for separating uses and implementation of an object.
Two common types of abstractions
procedural or functional abstraction
and data abstraction.

procedural abstracton:
The procedural abstraction is a way of hiding the implementation details of a procedure or function from the user.

Data abstraction:
The data abstraction is a way of hiding the implementation details of a data structure from the user.

ADT are used by set of operations called interface

Constructors Create and initialize new instances of ADT
Accessors: Return data contained in an instance without modifying it
Mutators: Modify the contents of an
ADT instance.
Iterators: Process individual data
components sequentially.

Computational complexity:

Computational complexity is a measure of the amount of computational resources (such as time and memory) required to execute an algorithm. It is used to compare the efficiency of different algorithms and to predict the performance of an algorithm on different inputs.

The computational complexity of an algorithm is usually expressed in terms of the size of the input to the algorithm. For example, the computational complexity of a sorting algorithm might be expressed as O(n log n), where n is the size of the input list.

There are two main types of computational complexity: time complexity and space complexity.
Time complexity is a measure of the amount of time an algorithm takes to execute, usually expressed in terms
of the size of the input. Space complexity is a measure of the amount of memory an algorithm uses, usually expressed in terms of the size of the input.

Analyze complexity:
Pratical/Experimental analysis: Measure the time and space complexity of an algorithm by running it on a variety of inputs and measuring the resources used.
Functional/Theoretical analysis: Analyze the time and space complexity of an algorithm using mathematical techniques such as asymptotic analysis.

order of n/asymptotic analysis:
It is the analytical process to find the space or time complexity in terms of n (input size)
1:f(n) = 100n +1
2:f(n) = n^2 + 2n + 1
3: f(n) = 700
hence the order of n is n^2 for 2 solution algorithm, n for 1 ,and 1 for 3algo by aysmptotic analysis.

To find order of n we use aysmptotic analysis.
aysmptote:
when we represnt something upto a certain limit or infinity
It is the best method but accurate

Analysis Cases of aysmptote:
Good: when the value of n is small, so time execution is small
Bad: when the value of n is large, so time execution is large
Average: Average
*always write a algo on worst case

Linear search program:
Linear search is a simple search algorithm that searches for an element in a list by checking each element in the list one by one until the element is found or the end of the list is reached.
eg in linear search of key = 1 in a list of [2,4,5,6,1,9]
Best case is when 2 is searched
Worst case is when 9 is searched
Average case is when 5 is searched

Binary search program:
Binary search is a search algorithm that finds the position of a target value within a sorted array. It works by repeatedly dividing the search interval in half. If the value of the search key is less than the item in the middle of the interval, the search continues in the lower half, otherwise it continues in the upper half. This process continues until the value is found or the interval is empty.

Bubble sort program:
Bubble sort is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order. The pass through the list is repeated until the list is sorted.

As there are three analysis cases, there are 3 aysmptote notation

1:Big O notation(worst case)
2:Big Omega notation(best case)
3:Big Theta notation(average case)

Big O notation:
Big O notation is a mathematical notation that describes the limiting behavior of a function when the argument tends towards a particular value or infinity. It is used to describe the time complexity of an algorithm.

Big O notations:
O(1) - constant time complexity: the algorithm takes the same amount of time regardless of the size of the input.
O(log n) - logarithmic time complexity: the algorithm takes time proportional to the logarithm of the size of the input.The program runs less than the size of the input. Size of input decreases in each step eg binary seacrh 
O(n) - linear time complexity: the algorithm takes time proportional to the size of the input. eg linear search
O(n log n) - linearithmic time  complexity/Quasilinear:First the complexity increases as n increases and then it decreases eg merge sort
O(n^2) - quadratic time complexity:
The algorithm takes time proportional to the square of the size of the input. eg bubble sort
O(2^n) - exponential time complexity:
The algorithm takes time proportional to 2 raised to the power of the size of the input. eg fibonacci series
O(n!) - factorial time complexity:
The algorithm takes time proportional to the factorial of the size of the input. eg travelling salesman problem


